<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PaLaTyPuS - Adaptive Reality Synthesis</title>
    <meta name="description" content="PaLaTyPuS - experimental music meets adaptive live-coded visuals. Responsive synthesis engine.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #00ff88;
            --secondary-color: #0080ff;
            --accent-color: #ff0080;
            --bg-alpha: 0.8;
            --border-width: 1px;
            --text-size: 12px;
            --spacing: 20px;
        }

        /* Screen size dependent variables */
        @media (max-width: 480px) {
            :root {
                --primary-color: #ff6b35;
                --secondary-color: #f7931e;
                --accent-color: #ffb627;
                --bg-alpha: 0.9;
                --border-width: 2px;
                --text-size: 10px;
                --spacing: 12px;
            }
        }

        @media (min-width: 481px) and (max-width: 768px) {
            :root {
                --primary-color: #6b5b95;
                --secondary-color: #88d8c0;
                --accent-color: #feb236;
                --bg-alpha: 0.85;
                --border-width: 1.5px;
                --text-size: 11px;
                --spacing: 16px;
            }
        }

        @media (min-width: 1200px) {
            :root {
                --primary-color: #00ff88;
                --secondary-color: #0080ff;
                --accent-color: #ff0080;
                --bg-alpha: 0.7;
                --border-width: 1px;
                --text-size: 14px;
                --spacing: 24px;
            }
        }

        @media (orientation: portrait) {
            :root {
                --primary-color: #e74c3c;
                --secondary-color: #9b59b6;
                --accent-color: #f39c12;
            }
        }

        body {
            font-family: 'Courier New', monospace;
            color: var(--primary-color);
            background: #000;
            overflow-x: hidden;
            cursor: crosshair;
        }

        /* Adaptive canvas that changes behavior based on screen */
        #visual-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: #000;
            transition: filter 0.3s ease;
        }

        /* Screen-size adaptive overlays */
        .code-overlay {
            position: fixed;
            background: rgba(0, 0, 0, var(--bg-alpha));
            border: var(--border-width) solid var(--primary-color);
            border-radius: calc(var(--spacing) * 0.4);
            padding: var(--spacing);
            font-family: 'Courier New', monospace;
            font-size: var(--text-size);
            line-height: 1.4;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 0 calc(var(--spacing) * 1.5) rgba(var(--primary-color), 0.3);
        }

        /* Desktop layout */
        @media (min-width: 769px) {
            .code-overlay {
                top: var(--spacing);
                left: var(--spacing);
                max-width: 400px;
            }
            
            .code-overlay.minimized {
                transform: translateX(-350px);
            }
        }

        /* Tablet landscape layout */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: landscape) {
            .code-overlay {
                top: 50%;
                right: var(--spacing);
                transform: translateY(-50%);
                max-width: 300px;
            }
            
            .code-overlay.minimized {
                transform: translate(250px, -50%);
            }
        }

        /* Tablet portrait layout */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: portrait) {
            .code-overlay {
                bottom: 120px;
                left: var(--spacing);
                right: var(--spacing);
                max-width: none;
            }
            
            .code-overlay.minimized {
                transform: translateY(100px);
            }
        }

        /* Mobile layout - bottom drawer style */
        @media (max-width: 480px) {
            .code-overlay {
                bottom: 0;
                left: 0;
                right: 0;
                max-width: none;
                border-radius: calc(var(--spacing) * 0.8) calc(var(--spacing) * 0.8) 0 0;
                border-bottom: none;
                max-height: 40vh;
                overflow-y: auto;
            }
            
            .code-overlay.minimized {
                transform: translateY(calc(100% - 40px));
            }
        }

        .code-toggle {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: var(--primary-color);
            border: var(--border-width) solid var(--primary-color);
            padding: calc(var(--spacing) * 0.25);
            cursor: pointer;
            font-size: calc(var(--text-size) * 0.8);
            transition: all 0.3s ease;
        }

        /* Adaptive toggle positioning */
        @media (min-width: 769px) {
            .code-toggle {
                right: calc(var(--spacing) * -1.5);
                top: 50%;
                transform: translateY(-50%);
                border-radius: 0 5px 5px 0;
                writing-mode: vertical-rl;
            }
        }

        @media (max-width: 768px) {
            .code-toggle {
                top: calc(var(--spacing) * -1.5);
                left: 50%;
                transform: translateX(-50%);
                border-radius: 5px 5px 0 0;
                writing-mode: horizontal-tb;
            }
        }

        .live-code {
            color: var(--primary-color);
            margin-bottom: calc(var(--spacing) * 0.4);
            opacity: 0.7;
            transition: all 0.3s ease;
            word-break: break-all;
        }

        .live-code.active {
            opacity: 1;
            color: var(--accent-color);
            background: rgba(255, 255, 0, 0.1);
            padding: calc(var(--spacing) * 0.1) calc(var(--spacing) * 0.2);
            border-radius: 3px;
            transform: scale(1.02);
        }

        /* Responsive audio visualizer */
        .audio-viz {
            position: fixed;
            z-index: 100;
            pointer-events: none;
            display: flex;
            align-items: flex-end;
            gap: 1px;
        }

        /* Desktop: bottom full width */
        @media (min-width: 769px) {
            .audio-viz {
                bottom: var(--spacing);
                left: var(--spacing);
                right: var(--spacing);
                height: 60px;
            }
        }

        /* Tablet landscape: vertical on left */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: landscape) {
            .audio-viz {
                left: var(--spacing);
                top: var(--spacing);
                bottom: var(--spacing);
                width: 40px;
                height: auto;
                flex-direction: column;
                align-items: center;
            }
            
            .viz-bar {
                width: 100% !important;
                min-height: 2px !important;
            }
        }

        /* Mobile: top thin strip */
        @media (max-width: 480px) {
            .audio-viz {
                top: var(--spacing);
                left: var(--spacing);
                right: var(--spacing);
                height: 25px;
            }
        }

        .viz-bar {
            flex: 1;
            background: linear-gradient(to top, var(--primary-color), var(--secondary-color), var(--accent-color));
            min-height: 2px;
            border-radius: 1px;
            transition: all 0.1s ease;
            min-width: 2px;
        }

        /* Adaptive navigation */
        .nav-container {
            position: fixed;
            z-index: 1000;
            display: flex;
            gap: calc(var(--spacing) * 0.75);
        }

        /* Desktop: top right */
        @media (min-width: 769px) {
            .nav-container {
                top: var(--spacing);
                right: var(--spacing);
                flex-direction: row;
            }
        }

        /* Tablet: varies by orientation */
        @media (min-width: 481px) and (max-width: 768px) and (orientation: landscape) {
            .nav-container {
                top: var(--spacing);
                left: 80px;
                right: var(--spacing);
                justify-content: center;
            }
        }

        @media (min-width: 481px) and (max-width: 768px) and (orientation: portrait) {
            .nav-container {
                top: var(--spacing);
                left: var(--spacing);
                right: var(--spacing);
                justify-content: space-between;
                flex-wrap: wrap;
            }
        }

        /* Mobile: bottom fixed */
        @media (max-width: 480px) {
            .nav-container {
                bottom: var(--spacing);
                left: var(--spacing);
                right: var(--spacing);
                justify-content: space-between;
                background: rgba(0, 0, 0, 0.9);
                padding: calc(var(--spacing) * 0.5);
                border-radius: calc(var(--spacing) * 0.5);
                border: var(--border-width) solid var(--primary-color);
            }
        }

        .nav-item {
            background: rgba(0, 0, 0, var(--bg-alpha));
            border: var(--border-width) solid var(--primary-color);
            color: var(--primary-color);
            padding: calc(var(--spacing) * 0.4) calc(var(--spacing) * 0.6);
            text-decoration: none;
            font-family: 'Courier New', monospace;
            font-size: var(--text-size);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: calc(var(--spacing) * 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }

        @media (max-width: 480px) {
            .nav-item {
                font-size: calc(var(--text-size) * 0.8);
                padding: calc(var(--spacing) * 0.3) calc(var(--spacing) * 0.4);
            }
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .nav-item:hover::before {
            left: 100%;
        }

        .nav-item:hover {
            color: var(--accent-color);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        /* Responsive content sections */
        .content-section {
            position: relative;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing);
            backdrop-filter: blur(2px);
        }

        .content-panel {
            background: rgba(0, 0, 0, var(--bg-alpha));
            border: var(--border-width) solid var(--primary-color);
            border-radius: calc(var(--spacing) * 0.6);
            padding: var(--spacing);
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 calc(var(--spacing) * 2) rgba(255, 255, 255, 0.1);
        }

        /* Responsive panel sizing */
        @media (min-width: 1200px) {
            .content-panel {
                max-width: 900px;
                width: 100%;
                padding: calc(var(--spacing) * 2);
            }
        }

        @media (min-width: 769px) and (max-width: 1199px) {
            .content-panel {
                max-width: 700px;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .content-panel {
                width: 100%;
                max-width: none;
                margin: 0 var(--spacing);
                border-radius: calc(var(--spacing) * 0.8);
            }
        }

        .content-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color), var(--primary-color));
            background-size: 400% 400%;
            border-radius: calc(var(--spacing) * 0.6);
            z-index: -1;
            animation: border-cycle 4s linear infinite;
        }

        @keyframes border-cycle {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .section-title {
            color: var(--primary-color);
            margin-bottom: calc(var(--spacing) * 1.5);
            font-family: 'Courier New', monospace;
            text-align: center;
            position: relative;
        }

        /* Responsive title sizing */
        @media (min-width: 1200px) {
            .section-title {
                font-size: 3rem;
            }
        }

        @media (min-width: 769px) and (max-width: 1199px) {
            .section-title {
                font-size: 2.5rem;
            }
        }

        @media (min-width: 481px) and (max-width: 768px) {
            .section-title {
                font-size: 2rem;
            }
        }

        @media (max-width: 480px) {
            .section-title {
                font-size: 1.5rem;
                margin-bottom: var(--spacing);
            }
        }

        .section-title::after {
            content: '_';
            animation: cursor-blink 1.5s infinite;
        }

        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .code-block {
            background: rgba(0, 20, 0, 0.8);
            border: var(--border-width) solid #004400;
            border-radius: calc(var(--spacing) * 0.3);
            padding: var(--spacing);
            margin: var(--spacing) 0;
            font-family: 'Courier New', monospace;
            font-size: var(--text-size);
            line-height: 1.6;
            color: var(--primary-color);
            position: relative;
            overflow: auto;
        }

        .code-block::before {
            content: '> ';
            color: var(--accent-color);
        }

        /* Responsive music container */
        .music-container {
            display: grid;
            gap: var(--spacing);
            margin: var(--spacing) 0;
        }

        @media (min-width: 769px) {
            .music-container {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .music-container {
                grid-template-columns: 1fr;
            }
        }

        .embed-wrapper {
            border: var(--border-width) solid var(--primary-color);
            border-radius: calc(var(--spacing) * 0.4);
            overflow: hidden;
            position: relative;
            background: rgba(0, 0, 0, 0.5);
        }

        .embed-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            animation: progress-bar 3s ease-in-out infinite;
            z-index: 1;
        }

        @keyframes progress-bar {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        /* Responsive control panel */
        .control-panel {
            position: fixed;
            background: rgba(0, 0, 0, var(--bg-alpha));
            border: var(--border-width) solid var(--primary-color);
            border-radius: calc(var(--spacing) * 0.4);
            padding: var(--spacing);
            backdrop-filter: blur(15px);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        @media (min-width: 1200px) {
            .control-panel {
                bottom: 100px;
                right: var(--spacing);
                width: 250px;
            }
        }

        @media (min-width: 769px) and (max-width: 1199px) {
            .control-panel {
                top: 50%;
                right: var(--spacing);
                transform: translateY(-50%);
                width: 200px;
            }
        }

        @media (max-width: 768px) {
            .control-panel {
                top: var(--spacing);
                right: var(--spacing);
                width: 180px;
            }
            
            .control-panel.minimized {
                transform: translateX(150px);
            }
        }

        .control-panel h4 {
            color: var(--primary-color);
            margin-bottom: calc(var(--spacing) * 0.75);
            font-size: calc(var(--text-size) + 2px);
        }

        .control-slider {
            display: flex;
            align-items: center;
            margin-bottom: calc(var(--spacing) * 0.5);
            gap: calc(var(--spacing) * 0.5);
        }

        .control-slider label {
            color: #888;
            font-size: calc(var(--text-size) - 1px);
            min-width: 50px;
        }

        .control-slider input[type="range"] {
            flex: 1;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Touch-friendly interactions for mobile */
        @media (max-width: 768px) {
            .control-slider input[type="range"]::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }
            
            .nav-item {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Cursor trail effects */
        .cursor-trail {
            position: fixed;
            width: 4px;
            height: 4px;
            background: var(--primary-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: screen;
            transition: all 0.3s ease;
        }

        /* Responsive scaling */
        @media (max-width: 480px) {
            .cursor-trail {
                width: 6px;
                height: 6px;
            }
        }

        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .code-overlay, .control-panel, .nav-item {
                backdrop-filter: blur(20px);
            }
        }

        /* Ultra-wide screens */
        @media (min-width: 1600px) {
            .content-panel {
                max-width: 1200px;
            }
            
            .control-panel {
                width: 300px;
            }
            
            .code-overlay {
                max-width: 500px;
            }
        }

        /* Screen orientation specific styling */
        @media (orientation: landscape) and (max-height: 500px) {
            .content-section {
                min-height: auto;
                padding: calc(var(--spacing) * 0.5);
            }
            
            .section-title {
                font-size: 1.5rem !important;
                margin-bottom: calc(var(--spacing) * 0.5);
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media (prefers-high-contrast: high) {
            :root {
                --primary-color: #ffffff;
                --secondary-color: #ffffff;
                --accent-color: #ffff00;
                --bg-alpha: 0.95;
            }
        }

        /* Screen reader optimizations */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <!-- Full-screen adaptive canvas -->
    <canvas id="visual-canvas" aria-hidden="true"></canvas>

    <!-- Screen size indicator (for debugging) -->
    <div id="screen-debug" style="position: fixed; top: 5px; left: 5px; color: var(--primary-color); font-size: 10px; z-index: 2000; opacity: 0.5;"></div>

    <!-- Responsive audio visualizer -->
    <div class="audio-viz" id="audioViz" aria-hidden="true">
        <!-- Generated dynamically -->
    </div>

    <!-- Adaptive live coding overlay -->
    <div class="code-overlay" id="codeOverlay" role="complementary" aria-label="Live coding display">
        <div class="code-toggle" onclick="toggleCodeOverlay()" aria-label="Toggle code panel">CODE</div>
        <div class="live-code" id="code0">osc(20, 0.1, 0.8).out()</div>
        <div class="live-code" id="code1">noise(3).color(2, 0.5).out()</div>
        <div class="live-code" id="code2">shape(6).repeat(3,2).out()</div>
        <div class="live-code" id="code3">osc().modulate(noise(10)).out()</div>
        <div class="live-code" id="code4">voronoi().kaleid(8).out()</div>
        <div class="sr-only">Live visual synthesis code display</div>
    </div>

    <!-- Adaptive navigation -->
    <nav class="nav-container" role="navigation" aria-label="Main navigation">
        <a href="#music" class="nav-item">STREAM</a>
        <a href="#about" class="nav-item">PROCESS</a>
        <a href="#live" class="nav-item">LIVE</a>
        <a href="https://www.instagram.com/larkinsfinestliquids/" class="nav-item" target="_blank" rel="noopener">VISUALS</a>
        <a href="https://github.com/alexpensavalle" class="nav-item" target="_blank" rel="noopener">SOURCE</a>
    </nav>

    <!-- Responsive control panel -->
    <div class="control-panel" id="controlPanel" role="region" aria-label="Visual controls">
        <h4>LIVE_CONTROLS</h4>
        <div class="control-slider">
            <label for="freqSlider">FREQ:</label>
            <input type="range" id="freqSlider" min="1" max="50" value="20" aria-label="Frequency control">
        </div>
        <div class="control-slider">
            <label for="syncSlider">SYNC:</label>
            <input type="range" id="syncSlider" min="0" max="2" step="0.1" value="0.1" aria-label="Sync control">
        </div>
        <div class="control-slider">
            <label for="offsetSlider">OFFSET:</label>
            <input type="range" id="offsetSlider" min="0" max="2" step="0.1" value="0.8" aria-label="Offset control">
        </div>
        <div class="control-slider">
            <label for="speedSlider">SPEED:</label>
            <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1" aria-label="Speed control">
        </div>
    </div>

    <!-- Main Content -->
    <main>
        <section class="content-section" id="music">
            <div class="content-panel">
                <h1 class="section-title">PALATYPUS.INIT()</h1>
                
                <div class="code-block" role="code">
                    <span class="sr-only">Code block:</span>
                    // Adaptive visual synthesis engine
                    // Responds to screen dimensions and device capabilities
                    // Nature's jack-of-all-trades approach to responsive design
                </div>

                <div class="music-container">
                    <div class="embed-wrapper">
                        <iframe style="border-radius:12px" src="https://open.spotify.com/embed/artist/4ku7ePqgfHKnfsXybAKR9Z?utm_source=generator&theme=0" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy" title="Spotify player"></iframe>
                    </div>
                    
                    <div class="embed-wrapper">
                        <iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/940320025&color=%2300ff88&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true" title="SoundCloud player"></iframe>
                    </div>
                </div>

                <div class="code-block" role="code">
                    <span class="sr-only">Code block:</span>
                    viewport.onChange(() => {
                        patterns.adapt(screen.dimensions);
                        colors.shift(device.orientation);
                        complexity.scale(pixelDensity);
                    });
                </div>
            </div>
        </section>

        <section class="content-section" id="about">
            <div class="content-panel">
                <h2 class="section-title">ADAPTIVE.PROCESS</h2>
                
                <div class="code-block" role="code">
                    <span class="sr-only">Code block:</span>
                    function createResponsiveExperience() {
                        const context = detectEnvironment();
                        const visuals = synthesize(context.screen, context.device);
                        return evolve(visuals, user.interaction);
                    }
                </div>

                <p style="color: #888; line-height: 1.8; margin: 20px 0;">
                    This synthesis engine adapts its visual algorithms to your specific viewing environment. 
                    Mobile devices trigger warmer color palettes and simpler geometries, while desktop 
                    displays unlock complex multi-layered patterns. Portrait orientation shifts to 
                    emotional color schemes, landscape enables spatial complexity.
                </p>

                <div class="code-block" role="code">
                    <span class="sr-only">Code block:</span>
                    screen.onResize(() => {
                        if (mobile) patterns.simplify().colors.warm();
                        if (tablet) layout.reflow().interactions.touch();
                        if (desktop) complexity.increase().layers.multiply();
                        if (ultrawide) canvas.expand().details.enhance();
                    });
                </div>

                <p style="color: #888; line-height: 1.8; margin: 20px 0;">
                    Each breakpoint isn't just a layout change - it's a complete aesthetic transformation. 
                    The visual synthesis algorithms themselves morph based on available screen real estate, 
                    pixel density, and interaction capabilities.
                </p>
            </div>
        </section>

        <section class="content-section" id="live">
            <div class="content-panel">
                <h2 class="section-title">RESPONSIVE.SYNTHESIS</h2>
                
                <div class="code-block" role="code">
                    <span class="sr-only">Code block:</span>
                    // Interactions adapt to your device:
                    // Mobile: Touch gestures, swipe patterns
                    // Tablet: Multi-touch, orientation changes
                    // Desktop: Mouse tracking, keyboard shortcuts
                    // Ultrawide: Extended spatial complexity
                </div>

                <p style="color: #888; line-height: 1.8; margin: 20px 0;">
                    The synthesis engine detects your environment and adapts accordingly. Small screens 
                    prioritize focused, high-impact visuals. Large displays enable sprawling, complex 
                    compositions. Portrait orientation triggers emotional color shifts. High-DPI displays 
                    get enhanced detail rendering.
                </p>

                <div class="code-block" role="code">
                    <span class="sr-only">Code block:</span>
                    touch.onGesture(gesture => {
                        if (gesture.pinch) scale.zoom(gesture.delta);
                        if (gesture.swipe) pattern.cycle(gesture.direction);
                        if (gesture.tap) parameters.randomize(gesture.position);
                    });
                </div>

                <p style="color: #888; line-height: 1.8; margin: 20px 0;">
                    This creates a truly device-native experience where the same creative content 
                    feels completely different on each platform - not just responsive, but genuinely 
                    adaptive to the unique capabilities of your viewing environment.
                </p>

                <div style="text-align: center; margin-top: 40px;">
                    <a href="https://www.instagram.com/larkinsfinestliquids/" 
                       style="color: var(--primary-color); text-decoration: none; border: var(--border-width) solid var(--primary-color); padding: 12px 24px; border-radius: 6px; display: inline-block; transition: all 0.3s ease;"
                       onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                       onmouseout="this.style.backgroundColor='transparent'">
                        EXPLORE_ADAPTIVE_VISUALS â†’
                    </a>
                </div>
            </div>
        </section>
    </main>

    <script>
        // Enhanced responsive visual synthesis engine
        class AdaptiveVisualSynthesis {
            constructor() {
                this.canvas = document.getElementById('visual-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.animationId = null;
                
                // Device-aware parameters
                this.viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    aspectRatio: window.innerWidth / window.innerHeight,
                    orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait',
                    pixelRatio: window.devicePixelRatio || 1,
                    deviceType: this.detectDeviceType()
                };
                
                // Adaptive visual parameters
                this.params = {
                    freq: 20,
                    sync: 0.1,
                    offset: 0.8,
                    speed: 1,
                    mouseX: 0,
                    mouseY: 0,
                    time: 0,
                    complexity: this.calculateComplexity(),
                    colorMode: this.getColorMode(),
                    renderQuality: this.getRenderQuality()
                };
                
                this.currentPattern = 0;
                this.patterns = this.getDevicePatterns();
                
                this.init();
            }
            
            detectDeviceType() {
                const width = window.innerWidth;
                if (width <= 480) return 'mobile';
                if (width <= 768) return 'tablet';
                if (width <= 1200) return 'desktop';
                return 'ultrawide';
            }
            
            calculateComplexity() {
                const area = this.viewport.width * this.viewport.height;
                const pixelCount = area * this.viewport.pixelRatio;
                
                // Adjust complexity based on total pixels and device capability
                if (pixelCount < 500000) return 1; // Simple
                if (pixelCount < 2000000) return 2; // Medium
                if (pixelCount < 5000000) return 3; // High
                return 4; // Ultra
            }
            
            getColorMode() {
                if (this.viewport.deviceType === 'mobile') return 'warm';
                if (this.viewport.orientation === 'portrait') return 'emotional';
                if (this.viewport.aspectRatio > 2) return 'cool';
                return 'standard';
            }
            
            getRenderQuality() {
                const area = this.viewport.width * this.viewport.height;
                if (area < 400000) return 1; // Low quality for small screens
                if (area < 1000000) return 2; // Medium quality
                if (area < 2000000) return 3; // High quality
                return 4; // Ultra quality for large displays
            }
            
            getDevicePatterns() {
                const base = ['oscillator', 'noise', 'shapes', 'modulation', 'voronoi'];
                
                switch (this.viewport.deviceType) {
                    case 'mobile':
                        return ['simple_osc', 'mobile_noise', 'touch_shapes'];
                    case 'tablet':
                        return ['tablet_osc', 'gesture_noise', 'adaptive_shapes', 'tablet_mod'];
                    case 'ultrawide':
                        return [...base, 'panoramic', 'multi_zone', 'spatial_complex'];
                    default:
                        return base;
                }
            }
            
            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.updateDebugInfo();
                this.animate();
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = this.viewport.pixelRatio;
                
                // Set actual canvas size in memory (scaled up for high DPI)
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Scale the drawing context to match device pixel ratio
                this.ctx.scale(dpr, dpr);
                
                // Set display size (CSS pixels)
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Update viewport info
                this.viewport.width = rect.width;
                this.viewport.height = rect.height;
                this.viewport.aspectRatio = rect.width / rect.height;
                this.viewport.orientation = rect.width > rect.height ? 'landscape' : 'portrait';
                
                // Recalculate adaptive parameters
                this.params.complexity = this.calculateComplexity();
                this.params.colorMode = this.getColorMode();
                this.params.renderQuality = this.getRenderQuality();
                this.patterns = this.getDevicePatterns();
            }
            
            setupEventListeners() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        const oldDeviceType = this.viewport.deviceType;
                        this.viewport.deviceType = this.detectDeviceType();
                        
                        this.resizeCanvas();
                        this.updateDebugInfo();
                        
                        // If device type changed, trigger adaptive UI update
                        if (oldDeviceType !== this.viewport.deviceType) {
                            this.adaptUI();
                        }
                    }, 100);
                });
                
                // Device-specific event listeners
                if (this.viewport.deviceType === 'mobile' || this.viewport.deviceType === 'tablet') {
                    this.setupTouchEvents();
                } else {
                    this.setupMouseEvents();
                }
                
                this.setupKeyboardEvents();
            }
            
            setupTouchEvents() {
                let lastTouch = { x: 0, y: 0 };
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    lastTouch = { x: touch.clientX, y: touch.clientY };
                    this.handleInteraction(touch.clientX, touch.clientY, 'touch');
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.params.mouseX = touch.clientX;
                    this.params.mouseY = touch.clientY;
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    // Gesture detection could go here
                });
                
                // Pinch to zoom for pattern complexity
                this.canvas.addEventListener('gesturechange', (e) => {
                    e.preventDefault();
                    this.params.complexity = Math.max(1, Math.min(4, this.params.complexity * e.scale));
                });
            }
            
            setupMouseEvents() {
                this.canvas.addEventListener('mousemove', (e) => {
                    this.params.mouseX = e.clientX;
                    this.params.mouseY = e.clientY;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    this.handleInteraction(e.clientX, e.clientY, 'click');
                });
                
                // Mouse wheel for parameter control
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (e.deltaY > 0) {
                        this.params.freq = Math.max(1, this.params.freq - 1);
                    } else {
                        this.params.freq = Math.min(100, this.params.freq + 1);
                    }
                    document.getElementById('freqSlider').value = this.params.freq;
                });
            }
            
            setupKeyboardEvents() {
                document.addEventListener('keydown', (e) => {
                    switch (e.code) {
                        case 'Space':
                            e.preventDefault();
                            this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
                            break;
                        case 'KeyR':
                            this.resetParameters();
                            break;
                        case 'KeyF':
                            if (document.fullscreenElement) {
                                document.exitFullscreen();
                            } else {
                                document.documentElement.requestFullscreen();
                            }
                            break;
                        case 'KeyC':
                            toggleCodeOverlay();
                            break;
                    }
                });
            }
            
            handleInteraction(x, y, type) {
                // Adaptive interaction based on device
                switch (this.viewport.deviceType) {
                    case 'mobile':
                        this.mobileInteraction(x, y, type);
                        break;
                    case 'tablet':
                        this.tabletInteraction(x, y, type);
                        break;
                    default:
                        this.desktopInteraction(x, y, type);
                }
            }
            
            mobileInteraction(x, y, type) {
                // Simple, immediate feedback for mobile
                this.currentPattern = Math.floor(Math.random() * this.patterns.length);
                this.params.freq = Math.random() * 30 + 10;
                this.params.offset = Math.random() * 2;
            }
            
            tabletInteraction(x, y, type) {
                // Medium complexity interactions
                if (type === 'touch') {
                    const centerX = this.viewport.width / 2;
                    const centerY = this.viewport.height / 2;
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    this.params.freq = (distance / this.viewport.width) * 50 + 5;
                    this.params.sync = (y / this.viewport.height) * 2;
                }
            }
            
            desktopInteraction(x, y, type) {
                // Complex interactions for desktop
                if (type === 'click') {
                    const quadrant = this.getQuadrant(x, y);
                    switch (quadrant) {
                        case 0: this.params.freq = Math.random() * 50 + 1; break;
                        case 1: this.params.sync = Math.random() * 2; break;
                        case 2: this.params.offset = Math.random() * 2; break;
                        case 3: this.currentPattern = Math.floor(Math.random() * this.patterns.length); break;
                    }
                }
            }
            
            getQuadrant(x, y) {
                const midX = this.viewport.width / 2;
                const midY = this.viewport.height / 2;
                
                if (x < midX && y < midY) return 0; // Top-left
                if (x >= midX && y < midY) return 1; // Top-right
                if (x < midX && y >= midY) return 2; // Bottom-left
                return 3; // Bottom-right
            }
            
            adaptUI() {
                // Trigger CSS custom property updates based on device type
                const root = document.documentElement;
                
                switch (this.viewport.deviceType) {
                    case 'mobile':
                        root.style.setProperty('--adaptive-complexity', '1');
                        root.style.setProperty('--adaptive-spacing', '12px');
                        break;
                    case 'tablet':
                        root.style.setProperty('--adaptive-complexity', '2');
                        root.style.setProperty('--adaptive-spacing', '16px');
                        break;
                    case 'desktop':
                        root.style.setProperty('--adaptive-complexity', '3');
                        root.style.setProperty('--adaptive-spacing', '20px');
                        break;
                    case 'ultrawide':
                        root.style.setProperty('--adaptive-complexity', '4');
                        root.style.setProperty('--adaptive-spacing', '24px');
                        break;
                }
            }
            
            updateDebugInfo() {
                const debug = document.getElementById('screen-debug');
                if (debug) {
                    debug.textContent = `${this.viewport.deviceType} ${this.viewport.width}x${this.viewport.height} ${this.viewport.orientation} Q${this.params.renderQuality} C${this.params.complexity}`;
                }
            }
            
            // Adaptive rendering methods
            drawAdaptiveOscillator() {
                const quality = this.params.renderQuality;
                const step = Math.max(1, 5 - quality); // Higher quality = smaller step
                
                const imageData = this.ctx.createImageData(this.viewport.width, this.viewport.height);
                const data = imageData.data;
                
                for (let x = 0; x < this.viewport.width; x += step) {
                    for (let y = 0; y < this.viewport.height; y += step) {
                        const i = (y * this.viewport.width + x) * 4;
                        
                        // Adaptive oscillator complexity
                        const wave1 = Math.sin(x * 0.01 * this.params.freq + this.params.time * this.params.speed);
                        let wave2 = Math.cos(y * 0.01 * this.params.freq + this.params.time * this.params.speed * this.params.sync);
                        let wave3 = Math.sin((x + y) * 0.005 * this.params.freq + this.params.time * this.params.speed + this.params.offset);
                        
                        // Add complexity layers based on device capability
                        if (this.params.complexity > 1) {
                            wave2 += Math.sin(x * 0.02 + this.params.time * 0.7) * 0.5;
                        }
                        if (this.params.complexity > 2) {
                            wave3 += Math.cos(y * 0.015 + this.params.time * 1.2) * 0.3;
                        }
                        if (this.params.complexity > 3) {
                            const fractal = Math.sin(x * 0.005 + y * 0.005 + this.params.time) * 0.2;
                            wave1 += fractal;
                        }
                        
                        // Mouse/touch influence
                        const mouseInfluence = Math.sin(Math.sqrt(Math.pow(x - this.params.mouseX, 2) + Math.pow(y - this.params.mouseY, 2)) * 0.01 + this.params.time * 2);
                        
                        // Color mode adaptation
                        let r, g, b;
                        switch (this.params.colorMode) {
                            case 'warm':
                                r = (wave1 + mouseInfluence) * 127 + 128;
                                g = (wave2 + mouseInfluence) * 80 + 100;
                                b = (wave3 + mouseInfluence) * 40 + 60;
                                break;
                            case 'cool':
                                r = (wave1 + mouseInfluence) * 40 + 60;
                                g = (wave2 + mouseInfluence) * 100 + 128;
                                b = (wave3 + mouseInfluence) * 127 + 128;
                                break;
                            case 'emotional':
                                r = (wave1 + mouseInfluence) * 100 + 155;
                                g = (wave2 + mouseInfluence) * 60 + 80;
                                b = (wave3 + mouseInfluence) * 120 + 135;
                                break;
                            default:
                                r = (wave1 + mouseInfluence) * 127 + 128;
                                g = (wave2 + mouseInfluence) * 127 + 128;
                                b = (wave3 + mouseInfluence) * 127 + 128;
                        }
                        
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                        data[i + 3] = 255;
                        
                        // Fill in the step area for lower quality rendering
                        if (step > 1) {
                            for (let dx = 0; dx < step && x + dx < this.viewport.width; dx++) {
                                for (let dy = 0; dy < step && y + dy < this.viewport.height; dy++) {
                                    const fillI = ((y + dy) * this.viewport.width + (x + dx)) * 4;
                                    data[fillI] = r;
                                    data[fillI + 1] = g;
                                    data[fillI + 2] = b;
                                    data[fillI + 3] = 255;
                                }
                            }
                        }
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            drawAdaptiveShapes() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.viewport.width, this.viewport.height);
                
                // Adaptive shape complexity and count
                const baseCount = Math.min(10, Math.max(3, Math.floor(this.params.complexity * 2.5)));
                const repeatX = this.viewport.aspectRatio > 1.5 ? Math.floor(baseCount * 1.5) : baseCount;
                const repeatY = baseCount;
                
                for (let rx = 0; rx < repeatX; rx++) {
                    for (let ry = 0; ry < repeatY; ry++) {
                        const x = (this.viewport.width / repeatX) * rx + (this.viewport.width / repeatX) / 2;
                        const y = (this.viewport.height / repeatY) * ry + (this.viewport.height / repeatY) / 2;
                        
                        // Adaptive sizing based on screen size
                        const baseRadius = Math.min(this.viewport.width, this.viewport.height) * 0.02;
                        const radius = baseRadius + Math.sin(this.params.time * this.params.speed + rx + ry) * (baseRadius * 0.5);
                        const rotation = this.params.time * this.params.speed * 0.5 + rx * 0.5;
                        
                        // Adaptive side count based on complexity
                        const sides = Math.max(3, Math.min(12, 3 + this.params.complexity));
                        
                        this.ctx.save();
                        this.ctx.translate(x, y);
                        this.ctx.rotate(rotation);
                        
                        this.ctx.beginPath();
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides;
                            const px = Math.cos(angle) * radius;
                            const py = Math.sin(angle) * radius;
                            if (i === 0) this.ctx.moveTo(px, py);
                            else this.ctx.lineTo(px, py);
                        }
                        this.ctx.closePath();
                        
                        // Adaptive coloring
                        let hue;
                        switch (this.params.colorMode) {
                            case 'warm':
                                hue = (this.params.time * 20 + rx * 30 + ry * 60) % 60 + 300; // Reds/oranges
                                break;
                            case 'cool':
                                hue = (this.params.time * 20 + rx * 30 + ry * 60) % 120 + 180; // Blues/cyans
                                break;
                            case 'emotional':
                                hue = (this.params.time * 40 + rx * 45 + ry * 90) % 60 + 270; // Purples/magentas
                                break;
                            default:
                                hue = (this.params.time * 30 + rx * 60 + ry * 120 + this.params.mouseX * 0.1) % 360;
                        }
                        
                        this.ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
                        this.ctx.lineWidth = Math.max(1, this.params.renderQuality);
                        this.ctx.stroke();
                        
                        // Add fill for higher complexity
                        if (this.params.complexity > 2) {
                            this.ctx.fillStyle = `hsla(${hue}, 60%, 40%, 0.3)`;
                            this.ctx.fill();
                        }
                        
                        this.ctx.restore();
                    }
                }
            }
            
            animate() {
                this.params.time += 0.016 * this.params.speed;
                
                // Clear with adaptive method
                if (this.params.renderQuality > 2) {
                    this.ctx.clearRect(0, 0, this.viewport.width, this.viewport.height);
                } else {
                    // Faster clear for low-end devices
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, this.viewport.width, this.viewport.height);
                }
                
                // Render current pattern with adaptive quality
                const currentPatternName = this.patterns[this.currentPattern] || 'oscillator';
                
                switch (currentPatternName) {
                    case 'simple_osc':
                    case 'tablet_osc':
                    case 'oscillator':
                        this.drawAdaptiveOscillator();
                        break;
                    case 'adaptive_shapes':
                    case 'touch_shapes':
                    case 'shapes':
                        this.drawAdaptiveShapes();
                        break;
                    // Add more adaptive patterns here
                    default:
                        this.drawAdaptiveOscillator();
                }
                
                this.updateLiveCodeDisplay();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            updateLiveCodeDisplay() {
                const codeElements = document.querySelectorAll('.live-code');
                codeElements.forEach((el, index) => {
                    el.classList.remove('active');
                });
                
                const activeIndex = Math.floor(this.params.time * 0.5) % codeElements.length;
                if (codeElements[activeIndex]) {
                    codeElements[activeIndex].classList.add('active');
                }
            }
            
            resetParameters() {
                this.params.freq = 20;
                this.params.sync = 0.1;
                this.params.offset = 0.8;
                this.params.speed = 1;
                
                // Update UI controls
                const sliders = ['freqSlider', 'syncSlider', 'offsetSlider', 'speedSlider'];
                sliders.forEach((id, index) => {
                    const slider = document.getElementById(id);
                    if (slider) {
                        slider.value = [20, 0.1, 0.8, 1][index];
                    }
                });
            }
        }
        
        // Audio visualization with adaptive complexity
        function setupAdaptiveAudioViz() {
            const audioViz = document.getElementById('audioViz');
            const deviceType = window.innerWidth <= 480 ? 'mobile' : 
                              window.innerWidth <= 768 ? 'tablet' : 'desktop';
            
            // Adaptive bar count based on screen size and performance
            let numBars;
            switch (deviceType) {
                case 'mobile': numBars = 32; break;
                case 'tablet': numBars = 48; break;
                default: numBars = 64;
            }
            
            // Clear existing bars
            audioViz.innerHTML = '';
            
            for (let i = 0; i < numBars; i++) {
                const bar = document.createElement('div');
                bar.className = 'viz-bar';
                audioViz.appendChild(bar);
            }
            
            // Adaptive animation frequency
            const animationInterval = deviceType === 'mobile' ? 100 : 50;
            
            setInterval(() => {
                const bars = audioViz.querySelectorAll('.viz-bar');
                bars.forEach((bar, index) => {
                    const height = Math.sin(Date.now() * 0.002 + index * 0.2) * 30 + 10;
                    bar.style.height = Math.max(2, height) + 'px';
                });
            }, animationInterval);
        }
        
        // Adaptive cursor trail
        function setupAdaptiveCursorTrail() {
            const trails = [];
            const deviceType = window.innerWidth <= 768 ? 'touch' : 'mouse';
            const maxTrails = deviceType === 'touch' ? 10 : 20;
            
            const eventType = deviceType === 'touch' ? 'touchmove' : 'mousemove';
            
            document.addEventListener(eventType, (e) => {
                const x = e.clientX || (e.touches && e.touches[0].clientX);
                const y = e.clientY || (e.touches && e.touches[0].clientY);
                
                if (!x || !y) return;
                
                // Create trail dot
                const trail = document.createElement('div');
                trail.className = 'cursor-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                document.body.appendChild(trail);
                
                trails.push(trail);
                
                // Remove old trails
                if (trails.length > maxTrails) {
                    const oldTrail = trails.shift();
                    if (oldTrail && oldTrail.parentNode) {
                        oldTrail.parentNode.removeChild(oldTrail);
                    }
                }
                
                // Fade out trail
                setTimeout(() => {
                    if (trail && trail.parentNode) {
                        trail.style.opacity = '0';
                        trail.style.transform = 'scale(0)';
                        setTimeout(() => {
                            if (trail.parentNode) {
                                trail.parentNode.removeChild(trail);
                            }
                        }, 300);
                    }
                }, deviceType === 'touch' ? 200 : 100);
            });
        }
        
        // Global functions
        function toggleCodeOverlay() {
            const overlay = document.getElementById('codeOverlay');
            overlay.classList.toggle('minimized');
        }
        
        function setupAdaptiveControls(visualEngine) {
            const controls = ['freqSlider', 'syncSlider', 'offsetSlider', 'speedSlider'];
            
            controls.forEach((id) => {
                const slider = document.getElementById(id);
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        const param = id.replace('Slider', '').toLowerCase();
                        if (param === 'freq') param = 'freq';
                        visualEngine.params[param] = parseFloat(e.target.value);
                    });
                }
            });
        }
        
        // Initialize everything
        let visualEngine;
        
        function init() {
            visualEngine = new AdaptiveVisualSynthesis();
            setupAdaptiveAudioViz();
            setupAdaptiveCursorTrail();
            setupAdaptiveControls(visualEngine);
        }
        
        // Event listeners
        window.addEventListener('load', init);
        
        // Reinitialize on significant viewport changes
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                // Check if device type actually changed
                const newDeviceType = window.innerWidth <= 480 ? 'mobile' : 
                                    window.innerWidth <= 768 ? 'tablet' : 
                                    window.innerWidth <= 1200 ? 'desktop' : 'ultrawide';
                
                if (visualEngine && newDeviceType !== visualEngine.viewport.deviceType) {
                    // Reinitialize audio viz for new device type
                    setupAdaptiveAudioViz();
                }
            }, 250);
        });
        
        // Orientation change handling
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (visualEngine) {
                    visualEngine.resizeCanvas();
                    visualEngine.adaptUI();
                    setupAdaptiveAudioViz();
                }
            }, 500); // Delay to allow for orientation change to complete
        });
    </script>
</body>
</html>